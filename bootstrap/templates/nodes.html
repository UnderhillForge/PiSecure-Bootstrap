<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PiSecure Network Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #00d4ff, #090979);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 212, 255, 0.3);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .recent-blocks-card {
            grid-column: span 2; /* Make Recent Blocks twice as wide */
        }

        .card {
            background: rgba(30, 30, 30, 0.8);
            border: 1px solid rgba(0, 212, 255, 0.2);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .card[data-card] {
            cursor: pointer;
        }

        .card[data-card]:focus-visible {
            outline: 2px solid #00d4ff;
            outline-offset: 4px;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0, 212, 255, 0.2);
            border-color: rgba(0, 212, 255, 0.4);
        }

        .card h3 {
            color: #00d4ff;
            margin-bottom: 15px;
            font-size: 1.3em;
            border-bottom: 2px solid rgba(0, 212, 255, 0.3);
            padding-bottom: 8px;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .metric:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .metric-label {
            font-weight: 500;
            color: #b0b0b0;
        }

        .metric-value {
            font-weight: bold;
            color: #00d4ff;
            font-size: 1.1em;
        }

        .status-healthy {
            color: #00ff88;
        }

        .status-warning {
            color: #ffaa00;
        }

        .status-error {
            color: #ff4444;
        }

        .status-initializing {
            color: #888888;
        }

        .blocks-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .blocks-table th,
        .blocks-table td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .blocks-table th {
            color: #00d4ff;
            font-weight: 600;
        }

        .blocks-table td {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .hash-cell {
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .footer {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            background: rgba(20, 20, 20, 0.8);
            border-radius: 10px;
            border: 1px solid rgba(0, 212, 255, 0.2);
        }

        .footer p {
            color: #888;
            font-size: 0.9em;
        }

        .last-updated {
            font-size: 0.8em;
            color: #666;
            margin-top: 10px;
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 2em;
            }
        }

        /* Pulse animation removed per user request */
        /*
        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        */

        /* Operator Value Estimation Section */
        .operator-value-section {
            margin: 30px auto;
            max-width: 1000px;
        }

        .operator-value-section .card {
            background: linear-gradient(135deg, rgba(30, 30, 30, 0.9) 0%, rgba(20, 20, 20, 0.9) 100%);
            border: 1px solid rgba(255, 193, 7, 0.3);
            box-shadow: 0 8px 32px rgba(255, 193, 7, 0.2);
        }

        .operator-value-section .card h3 {
            color: #ffc107;
            border-bottom-color: rgba(255, 193, 7, 0.3);
        }

        .value-metrics {
            margin-bottom: 20px;
        }

        .value-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .value-row:last-child {
            border-bottom: none;
        }

        .value-label {
            font-weight: 500;
            color: #b0b0b0;
            font-size: 0.95em;
        }

        .value-amount {
            font-weight: bold;
            color: #ffc107;
            font-size: 1.2em;
            font-family: 'Courier New', monospace;
        }

        .value-breakdown h4 {
            color: #ffc107;
            margin-bottom: 15px;
            font-size: 1.1em;
            border-bottom: 2px solid rgba(255, 193, 7, 0.3);
            padding-bottom: 8px;
        }

        .breakdown-list {
            margin-bottom: 20px;
        }

        .breakdown-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .breakdown-item:last-child {
            border-bottom: none;
        }

        .breakdown-label {
            color: #e0e0e0;
            font-size: 0.9em;
            flex: 1;
            margin-right: 15px;
        }

        .breakdown-value {
            color: #ffc107;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .value-disclaimer {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.2);
            border-radius: 6px;
            padding: 12px;
            margin-top: 15px;
        }

        .value-disclaimer p {
            color: #ddd;
            font-size: 0.8em;
            line-height: 1.4;
            margin: 0;
        }

        /* 314ST Token Valuation Section */
        .token-valuation-section {
            margin: 30px auto;
            max-width: 1000px;
        }

        .token-valuation-section .card {
            background: linear-gradient(135deg, rgba(30, 30, 30, 0.9) 0%, rgba(20, 20, 20, 0.9) 100%);
            border: 1px solid rgba(255, 193, 7, 0.3);
            box-shadow: 0 8px 32px rgba(255, 193, 7, 0.2);
        }

        .detail-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.65);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .detail-panel {
            width: min(90vw, 540px);
            max-height: 85vh;
            overflow-y: auto;
            background: rgba(15, 15, 20, 0.95);
            border-radius: 16px;
            border: 1px solid rgba(0, 212, 255, 0.2);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            padding: 24px;
            position: relative;
        }

        .detail-close {
            position: absolute;
            top: 10px;
            right: 12px;
            background: transparent;
            border: none;
            color: #e0e0e0;
            font-size: 1.6em;
            cursor: pointer;
        }

        .detail-body {
            margin-top: 10px;
            line-height: 1.5;
        }

        .detail-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .detail-list li {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            font-size: 0.95em;
        }

        .detail-list li span:last-child {
            font-weight: bold;
            color: #00d4ff;
            font-family: 'Courier New', monospace;
        }

        .detail-empty {
            color: #999;
            text-align: center;
            padding: 20px 0;
        }

        .hidden {
            display: none;
        }

        .token-valuation-section .card h3 {
            color: #ffc107;
            border-bottom-color: rgba(255, 193, 7, 0.3);
        }

        .token-valuation-section .card h4 {
            color: #ffc107;
            margin-bottom: 15px;
            font-size: 1.1em;
            border-bottom: 2px solid rgba(255, 193, 7, 0.3);
            padding-bottom: 8px;
        }

        .price-overview {
            margin-bottom: 20px;
        }

        .price-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .price-row:last-child {
            border-bottom: none;
        }

        .price-label {
            font-weight: 500;
            color: #b0b0b0;
            font-size: 0.95em;
        }

        .price-amount {
            font-weight: bold;
            color: #ffc107;
            font-size: 1.2em;
            font-family: 'Courier New', monospace;
        }

        .price-status {
            color: #888;
            font-size: 0.9em;
        }

        .launch-status {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .status-row:last-child {
            border-bottom: none;
        }

        .status-label {
            font-weight: 500;
            color: #b0b0b0;
            font-size: 0.9em;
        }

        .status-value {
            color: #ffc107;
            font-weight: bold;
            font-size: 0.9em;
        }

        .market-data, .supply-demand {
            margin-bottom: 20px;
        }

        .market-grid, .supply-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .market-item, .supply-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            padding: 12px;
        }

        .market-label, .supply-label {
            display: block;
            color: #b0b0b0;
            font-size: 0.8em;
            margin-bottom: 5px;
        }

        .market-value, .supply-value {
            display: block;
            color: #ffc107;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            font-size: 1em;
        }

        .valuation-breakdown {
            margin-bottom: 20px;
        }

        .sentiment-indicators {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .sentiment-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            padding: 12px;
        }

        .sentiment-label {
            display: block;
            color: #b0b0b0;
            font-size: 0.8em;
            margin-bottom: 5px;
        }

        .sentiment-value {
            display: block;
            color: #ffc107;
            font-weight: bold;
            font-size: 0.9em;
        }

        .valuation-disclaimer {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.2);
            border-radius: 6px;
            padding: 12px;
            margin-top: 15px;
        }

        .valuation-disclaimer p {
            color: #ddd;
            font-size: 0.8em;
            line-height: 1.4;
            margin: 0;
        }

        @media (max-width: 768px) {
            .token-valuation-section {
                margin: 20px 10px;
            }

            .price-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }

            .status-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }

            .market-grid, .supply-grid, .sentiment-indicators {
                grid-template-columns: 1fr;
            }

            .operator-value-section {
                margin: 20px 10px;
            }

            .value-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }

            .breakdown-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }

            .breakdown-value {
                align-self: flex-end;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üîó PiSecure Network Dashboard</h1>
        <p>Real-time blockchain network statistics and node information</p>
    </div>

    <div class="grid">
        <!-- Network Overview -->
        <div class="card" id="networkOverviewCard" data-card="network-overview" tabindex="0">
            <h3>üåê Network Overview</h3>
            <div class="metric">
                <span class="metric-label">Total Nodes</span>
                <span class="metric-value" id="totalNodes">--</span>
            </div>
            <div class="metric">
                <span class="metric-label">Active Nodes</span>
                <span class="metric-value status-healthy" id="activeNodes">--</span>
            </div>
            <div class="metric">
                <span class="metric-label">Network Hashrate</span>
                <span class="metric-value" id="networkHashrate">-- MH/s</span>
            </div>
            <div class="metric">
                <span class="metric-label">Block Height</span>
                <span class="metric-value" id="blockHeight">--</span>
            </div>
            <div class="metric">
                <span class="metric-label">Average Block Time</span>
                <span class="metric-value" id="avgBlockTime">--s</span>
            </div>
            <div class="metric">
                <span class="metric-label">Network Status</span>
                <span class="metric-value status-healthy" id="networkStatus">--</span>
            </div>
        </div>

        <!-- Network Health -->
        <div class="card" id="networkHealthCard" data-card="network-health" tabindex="0">
            <h3>üíö Network Health</h3>
            <div class="metric">
                <span class="metric-label">Health Status</span>
                <span class="metric-value status-healthy" id="healthStatus">--</span>
            </div>
            <div class="metric">
                <span class="metric-label">Average Latency</span>
                <span class="metric-value" id="avgLatency">--ms</span>
            </div>
            <div class="metric">
                <span class="metric-label">Packet Loss</span>
                <span class="metric-value" id="packetLoss">--%</span>
            </div>
            <div class="metric">
                <span class="metric-label">Sync Status</span>
                <span class="metric-value status-healthy" id="syncStatus">--</span>
            </div>
            <div class="metric">
                <span class="metric-label">Mempool Size</span>
                <span class="metric-value" id="mempoolSize">--</span>
            </div>
            <div class="metric">
                <span class="metric-label">Pending Transactions</span>
                <span class="metric-value" id="pendingTransactions">--</span>
            </div>
        </div>

        <!-- Mining Statistics -->
        <div class="card" id="miningStatsCard" data-card="mining-stats" tabindex="0">
            <h3>‚õèÔ∏è Mining Statistics</h3>
            <div class="metric">
                <span class="metric-label">Active Miners</span>
                <span class="metric-value" id="activeMiners">--</span>
            </div>
            <div class="metric">
                <span class="metric-label">Total Hashrate</span>
                <span class="metric-value" id="totalHashrate">-- MH/s</span>
            </div>
            <div class="metric">
                <span class="metric-label">Blocks Last Hour</span>
                <span class="metric-value" id="blocksLastHour">--</span>
            </div>
            <div class="metric">
                <span class="metric-label">Avg Blocks/Hour</span>
                <span class="metric-value" id="avgBlocksPerHour">--</span>
            </div>
            <div class="metric">
                <span class="metric-label">Top Miners</span>
                <span class="metric-value" id="topMiners">--</span>
            </div>
        </div>

        <!-- Protocol Information -->
        <div class="card" id="protocolInfoCard" data-card="protocol-info" tabindex="0">
            <h3>üìã Protocol Information</h3>
            <div class="metric">
                <span class="metric-label">Protocol Version</span>
                <span class="metric-value" id="protocolVersion">--</span>
            </div>
            <div class="metric">
                <span class="metric-label">Network ID</span>
                <span class="metric-value" id="networkId">--</span>
            </div>
            <div class="metric">
                <span class="metric-label">Consensus</span>
                <span class="metric-value" id="consensus">--</span>
            </div>
            <div class="metric">
                <span class="metric-label">Block Time Target</span>
                <span class="metric-value" id="blockTimeTarget">--</span>
            </div>
            <div class="metric">
                <span class="metric-label">Max Block Size</span>
                <span class="metric-value" id="maxBlockSize">--</span>
            </div>
            <div class="metric">
                <span class="metric-label">Circulating Supply</span>
                <span class="metric-value" id="circulatingSupply">--</span>
            </div>
        </div>

        <!-- Bootstrap Nodes -->
        <div class="card" id="bootstrapNodesCard" data-card="bootstrap-nodes" tabindex="0">
            <h3>üöÄ Bootstrap Nodes</h3>
            <div id="bootstrapNodesContent">
                <div class="metric">
                    <span class="metric-value status-initializing">Loading bootstrap nodes...</span>
                </div>
            </div>
        </div>

        <!-- Service Status -->
        <div class="card" id="serviceStatusCard" data-card="service-status" tabindex="0">
            <h3>‚öôÔ∏è Service Status</h3>
            <div id="serviceStatusContent">
                <div class="metric">
                    <span class="metric-value status-initializing">Loading services...</span>
                </div>
            </div>
        </div>

        <!-- Sentinel Intelligence -->
        <div class="card" id="sentinelIntelligenceCard" data-card="sentinel-intelligence" tabindex="0">
            <h3>üõ°Ô∏è Sentinel Intelligence</h3>
            <div class="metric">
                <span class="metric-label">Threat Level</span>
                <span class="metric-value" id="threatLevel">--</span>
            </div>
            <div class="metric">
                <span class="metric-label">Active Attacks</span>
                <span class="metric-value status-warning" id="activeAttacks">--</span>
            </div>
            <div class="metric">
                <span class="metric-label">Defense Effectiveness</span>
                <span class="metric-value status-healthy" id="defenseEffectiveness">--%</span>
            </div>
            <div class="metric">
                <span class="metric-label">Blocked IPs</span>
                <span class="metric-value" id="blockedIPs">--</span>
            </div>
            <div class="metric">
                <span class="metric-label">Active Threat Zones</span>
                <span class="metric-value" id="threatZones">--</span>
            </div>
            <div class="metric">
                <span class="metric-label">Sentinel Status</span>
                <span class="metric-value status-healthy" id="sentinelStatus">--</span>
            </div>
        </div>

        <!-- Recent Blocks -->
        <div class="card recent-blocks-card" id="recentBlocksCard" data-card="recent-blocks" tabindex="0">
            <h3>üì¶ Recent Blocks</h3>
            <table class="blocks-table">
                <thead>
                    <tr>
                        <th>Height</th>
                        <th>Hash</th>
                        <th>Miner</th>
                        <th>Transactions</th>
                        <th>Reward</th>
                    </tr>
                </thead>
                <tbody id="blocksTableBody">
                    <tr>
                        <td colspan="5" style="text-align: center; color: #888;">Loading recent blocks...</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <!-- Operator Value Estimation -->
    <div class="operator-value-section">
        <div class="card" id="operatorValueCard" data-card="operator-value" tabindex="0">
            <h3>üßÆ Operator Value Estimation</h3>

            <div class="value-metrics">
                <div class="value-row">
                    <span class="value-label">Net Monthly Value (USD)</span>
                    <span class="value-amount" id="monthlyValueUSD">--</span>
                </div>
                <div class="value-row">
                    <span class="value-label">Net Monthly Value (314ST)</span>
                    <span class="value-amount" id="monthlyValue314ST">--</span>
                </div>
                <div class="value-row">
                    <span class="value-label">Average Daily Value</span>
                    <span class="value-amount" id="dailyValueUSD">--</span>
                </div>
                <div class="value-row">
                    <span class="value-label">Average Hourly Value</span>
                    <span class="value-amount" id="hourlyValueUSD">--</span>
                </div>
            </div>

            <div class="value-breakdown">
                <h4>üìÇ Value Breakdown</h4>
                <div id="valueBreakdown" class="breakdown-list">
                    <div class="breakdown-item">
                        <span class="breakdown-label">Loading valuation data...</span>
                        <span class="breakdown-value">--</span>
                    </div>
                </div>
                <div class="value-disclaimer">
                    <p><small>* Estimates blend ML workload, DEX coordination, uptime incentives, and operator time. Values refresh every 5 minutes.</small></p>
                </div>
            </div>
        </div>
    </div>

    <!-- 314ST Token Valuation Dashboard -->
    <div class="token-valuation-section">
        <div class="card" id="tokenValuationCard" data-card="token-valuation" tabindex="0">
            <h3>üíé 314ST Token Valuation</h3>

            <!-- Price Overview -->
            <div class="price-overview">
                <div class="price-row">
                    <span class="price-label">Market Price (DEX)</span>
                    <span class="price-amount" id="marketPrice">--</span>
                    <span class="price-status" id="marketStatus">‚è≥ Pre-Market</span>
                </div>
                <div class="price-row">
                    <span class="price-label">Fundamental Value</span>
                    <span class="price-amount" id="fundamentalValue">$2.00</span>
                    <span class="price-status">üìä Fair Launch</span>
                </div>
                <div class="price-row">
                    <span class="price-label">Premium/Discount</span>
                    <span class="price-amount" id="premiumDiscount">--</span>
                    <span class="price-change" id="premiumChange">--</span>
                </div>
            </div>

            <!-- Fair Launch Status -->
            <div class="launch-status">
                <div class="status-row">
                    <span class="status-label">Mining Status</span>
                    <span class="status-value" id="miningStatus">‚è∏Ô∏è Awaiting Network Fixes</span>
                </div>
                <div class="status-row">
                    <span class="status-label">Tokens to Mine</span>
                    <span class="status-value" id="tokensToMine">200,000 314ST</span>
                </div>
                <div class="status-row">
                    <span class="status-label">Mined Progress</span>
                    <span class="status-value" id="miningProgress">0 / 200,000 314ST</span>
                </div>
            </div>

            <!-- DEX Market Data -->
            <div class="market-data">
                <h4>üìà DEX Market Data</h4>
                <div class="market-grid">
                    <div class="market-item">
                        <span class="market-label">Last Trade</span>
                        <span class="market-value" id="lastTrade">--</span>
                    </div>
                    <div class="market-item">
                        <span class="market-label">24h Volume</span>
                        <span class="market-value" id="volume24h">--</span>
                    </div>
                    <div class="market-item">
                        <span class="market-label">Liquidity</span>
                        <span class="market-value" id="liquidity">--</span>
                    </div>
                    <div class="market-item">
                        <span class="market-label">Active Pools</span>
                        <span class="market-value" id="activePools">--</span>
                    </div>
                </div>
            </div>

            <!-- Supply & Demand -->
            <div class="supply-demand">
                <h4>‚öñÔ∏è Supply & Demand</h4>
                <div class="supply-grid">
                    <div class="supply-item">
                        <span class="supply-label">Circulating Supply</span>
                        <span class="supply-value" id="circulatingSupply">0 / 200,000 314ST</span>
                    </div>
                    <div class="supply-item">
                        <span class="supply-label">Market Cap</span>
                        <span class="supply-value" id="marketCap">$0</span>
                    </div>
                    <div class="supply-item">
                        <span class="supply-label">FDV (at $2.00)</span>
                        <span class="supply-value" id="fdv">$400,000</span>
                    </div>
                    <div class="supply-item">
                        <span class="supply-label">Token Velocity</span>
                        <span class="supply-value" id="tokenVelocity">--</span>
                    </div>
                </div>
            </div>

            <!-- Valuation Breakdown -->
            <div class="valuation-breakdown">
                <h4>üìä Fundamental Breakdown</h4>
                <div id="valuationBreakdown" class="breakdown-list">
                    <div class="breakdown-item">
                        <span class="breakdown-label">Mining Cost Floor</span>
                        <span class="breakdown-value">$0.50</span>
                    </div>
                    <div class="breakdown-item">
                        <span class="breakdown-label">Development Value</span>
                        <span class="breakdown-value">$0.75</span>
                    </div>
                    <div class="breakdown-item">
                        <span class="breakdown-label">Security Utility</span>
                        <span class="breakdown-value">$0.25</span>
                    </div>
                    <div class="breakdown-item">
                        <span class="breakdown-label">Network Premium</span>
                        <span class="breakdown-value">$0.25</span>
                    </div>
                    <div class="breakdown-item">
                        <span class="breakdown-label">Fair Launch Bonus</span>
                        <span class="breakdown-value">$0.25</span>
                    </div>
                </div>
            </div>

            <!-- Market Sentiment -->
            <div class="market-sentiment">
                <h4>üé≠ Market Sentiment</h4>
                <div class="sentiment-indicators">
                    <div class="sentiment-item">
                        <span class="sentiment-label">Price Momentum</span>
                        <span class="sentiment-value" id="priceMomentum">‚è≥ Pre-Market</span>
                    </div>
                    <div class="sentiment-item">
                        <span class="sentiment-label">Trading Activity</span>
                        <span class="sentiment-value" id="tradingActivity">‚è∏Ô∏è No DEX Yet</span>
                    </div>
                    <div class="sentiment-item">
                        <span class="sentiment-label">Risk Level</span>
                        <span class="sentiment-value" id="riskLevel">üî¥ High (Pre-Launch)</span>
                    </div>
                    <div class="sentiment-item">
                        <span class="sentiment-label">Confidence Score</span>
                        <span class="sentiment-value" id="confidenceScore">75%</span>
                    </div>
                </div>
            </div>

            <div class="valuation-disclaimer">
                <p><small>* Fundamental value based on fair launch economics. Market price determined by DEX supply/demand. Values update in real-time as network develops.</small></p>
            </div>
        </div>
    </div>

    <div class="footer">
        <p>üîí Secure ‚Ä¢ üöÄ Fast ‚Ä¢ üåê Decentralized</p>
        <div class="last-updated">
            Last updated: <span id="lastUpdated">{{ last_updated }}</span>
        </div>
    </div>

    <div id="cardDetailOverlay" class="detail-overlay hidden">
        <div class="detail-panel" role="dialog" aria-modal="true" aria-labelledby="detailTitle">
            <button id="detailClose" class="detail-close" aria-label="Close detail view">&times;</button>
            <h3 id="detailTitle">Details</h3>
            <div id="detailBody" class="detail-body">
                <p class="detail-empty">Select a card to view real-time details.</p>
            </div>
        </div>
    </div>

    <script>
        const dashboardState = {
            networkOverview: null,
            networkHealth: null,
            miningStats: null,
            protocolInfo: null,
            bootstrapNodes: null,
            serviceStatus: null,
            sentinelIntelligence: null,
            recentBlocks: null,
            operatorValue: null,
            tokenValuation: null
        };

        let activeDetailCard = null;
        let lastUpdate = Date.now();

        const detailEmptyState = '<p class="detail-empty">Waiting for live telemetry...</p>';

        function buildDetailList(entries = []) {
            if (!entries.length) {
                return detailEmptyState;
            }
            const items = entries
                .filter(Boolean)
                .map(entry => `<li><span>${entry.label}</span><span>${entry.value ?? '--'}</span></li>`) 
                .join('');
            return `<ul class="detail-list">${items}</ul>`;
        }

        const cardDetailBuilders = {
            'network-overview': (state) => {
                const data = state.networkOverview;
                if (!data) {
                    return { title: 'Network Overview', content: detailEmptyState };
                }
                return {
                    title: 'Network Overview',
                    content: buildDetailList([
                        { label: 'Total Nodes', value: data.totalNodes },
                        { label: 'Active Nodes', value: data.activeNodes },
                        { label: 'Network Status', value: data.networkStatus },
                        { label: 'Hashrate', value: data.networkHashrate },
                        { label: 'Block Height', value: data.blockHeight },
                        { label: 'Average Block Time', value: data.avgBlockTime }
                    ])
                };
            },
            'network-health': (state) => {
                const data = state.networkHealth;
                if (!data) {
                    return { title: 'Network Health', content: detailEmptyState };
                }
                return {
                    title: 'Network Health',
                    content: buildDetailList([
                        { label: 'Overall Health', value: `${data.overallHealth}%` },
                        { label: 'Status', value: data.healthStatus },
                        { label: 'Average Latency', value: data.avgLatency },
                        { label: 'Packet Loss', value: data.packetLoss },
                        { label: 'Sync Status', value: data.syncStatus },
                        { label: 'Mempool Size', value: data.mempoolSize },
                        { label: 'Pending Transactions', value: data.pendingTransactions }
                    ])
                };
            },
            'mining-stats': (state) => {
                const data = state.miningStats;
                if (!data) {
                    return { title: 'Mining Statistics', content: detailEmptyState };
                }
                return {
                    title: 'Mining Statistics',
                    content: buildDetailList([
                        { label: 'Active Miners', value: data.activeMiners },
                        { label: 'Total Hashrate', value: data.totalHashrate },
                        { label: 'Blocks Last Hour', value: data.blocksLastHour },
                        { label: 'Average Blocks/Hour', value: data.avgBlocksPerHour },
                        { label: 'Top Miner Count', value: data.topMinerCount }
                    ])
                };
            },
            'protocol-info': (state) => {
                const data = state.protocolInfo;
                if (!data) {
                    return { title: 'Protocol Information', content: detailEmptyState };
                }
                return {
                    title: 'Protocol Information',
                    content: buildDetailList([
                        { label: 'Version', value: data.version },
                        { label: 'Network ID', value: data.networkId },
                        { label: 'Consensus', value: data.consensus },
                        { label: 'Block Target', value: data.blockTimeTarget },
                        { label: 'Max Block Size', value: data.maxBlockSize },
                        { label: 'Circulating Supply', value: data.circulatingSupply }
                    ])
                };
            },
            'bootstrap-nodes': (state) => {
                const data = state.bootstrapNodes;
                if (!data) {
                    return { title: 'Bootstrap Nodes', content: detailEmptyState };
                }
                const origin = data.origin || {};
                const localRole = origin.role ? origin.role.charAt(0).toUpperCase() + origin.role.slice(1) : 'Unknown';
                const localBadge = origin.primary_domain_match ? ' (Canonical Host)' : origin.role === 'primary' ? ' (Failover Primary)' : ' (This Server)';
                const secondaryList = (data.secondaryNodes || []).map(node => `${node.name || node.node_id} (${node.region || 'unknown'})`).join('<br>');
                return {
                    title: 'Bootstrap Nodes',
                    content: `
                        ${buildDetailList([
                            { label: 'Primary Node', value: data.primary?.name || data.primary?.node_id || '--' },
                            { label: 'Role', value: data.primary?.role || 'primary' },
                            { label: 'Operator', value: data.primary?.operator || 'PiSecure Foundation' },
                            { label: 'Acting Primary', value: data.primaryStatus?.acting_primary || 'Canonical' },
                            { label: 'Secondary Count', value: data.secondaryCount },
                            { label: 'This Server', value: `${localRole}${localBadge}` }
                        ])}
                        ${secondaryList ? `<p style="margin-top:12px;font-size:0.85em;color:#bbb;">Secondary Nodes:<br>${secondaryList}</p>` : ''}
                    `
                };
            },
            'service-status': (state) => {
                const data = state.serviceStatus;
                if (!data?.services) {
                    return { title: 'Service Status', content: detailEmptyState };
                }
                const items = Object.entries(data.services).map(([name, svc]) => ({
                    label: name.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' '),
                    value: svc.health || svc.status || '--'
                }));
                return {
                    title: 'Service Status',
                    content: buildDetailList(items)
                };
            },
            'sentinel-intelligence': (state) => {
                const data = state.sentinelIntelligence;
                if (!data) {
                    return { title: 'Sentinel Intelligence', content: detailEmptyState };
                }
                return {
                    title: 'Sentinel Intelligence',
                    content: buildDetailList([
                        { label: 'Threat Level', value: data.threatLevel },
                        { label: 'Active Attacks', value: data.activeAttacks },
                        { label: 'Defense Effectiveness', value: data.defenseEffectiveness },
                        { label: 'Blocked IPs', value: data.blockedIPs },
                        { label: 'Threat Zones', value: data.threatZones?.join(', ') || 'None' },
                        { label: 'Sentinel Status', value: data.sentinelStatus }
                    ])
                };
            },
            'recent-blocks': (state) => {
                const data = state.recentBlocks;
                if (!data?.length) {
                    return { title: 'Recent Blocks', content: '<p class="detail-empty">Blockchain not yet initialized.</p>' };
                }
                const rows = data.slice(0, 5).map(block => `
                    <li><span>#${block.height}</span><span>${block.transactions?.length || 0} tx</span></li>
                `).join('');
                return {
                    title: 'Recent Blocks',
                    content: `<ul class="detail-list">${rows}</ul>`
                };
            },
            'operator-value': (state) => {
                const data = state.operatorValue;
                if (!data) {
                    return { title: 'Operator Value', content: detailEmptyState };
                }
                const breakdown = Object.values(data.breakdown || {}).map(item => ({
                    label: item.description,
                    value: item.monthly_usd ? `$${item.monthly_usd.toLocaleString()}/mo` :
                        item.daily_usd ? `$${item.daily_usd.toLocaleString()}/day` :
                        item.hourly_usd ? `$${item.hourly_usd.toLocaleString()}/hr` :
                        item.percentage ? `${item.percentage}%` : '--'
                }));
                return {
                    title: 'Operator Value',
                    content: buildDetailList([
                        { label: 'Net Monthly (USD)', value: `$${data.totals?.net_value_monthly_usd?.toLocaleString() || '--'}` },
                        { label: 'Net Monthly (314ST)', value: data.totals?.net_value_monthly_314st?.toLocaleString() || '--' }
                    ]) + `<h4 style="margin-top:16px;color:#ffc107;">Breakdown</h4>${buildDetailList(breakdown)}`
                };
            },
            'token-valuation': (state) => {
                const data = state.tokenValuation;
                if (!data) {
                    return { title: '314ST Token Valuation', content: detailEmptyState };
                }
                return {
                    title: '314ST Token Valuation',
                    content: buildDetailList([
                        { label: 'Market Price', value: data.marketPrice },
                        { label: 'Fundamental Value', value: data.fundamentalValue },
                        { label: 'Premium/Discount', value: data.premium },
                        { label: 'Market Status', value: data.marketStatus },
                        { label: 'Last Trade', value: data.lastTrade },
                        { label: '24h Volume', value: data.volume24h },
                        { label: 'Liquidity', value: data.liquidity },
                        { label: 'Active Pools', value: data.activePools }
                    ])
                };
            }
        };

        function renderCardDetail(cardKey) {
            const builder = cardDetailBuilders[cardKey];
            if (!builder) {
                return;
            }
            const overlay = document.getElementById('cardDetailOverlay');
            const titleEl = document.getElementById('detailTitle');
            const bodyEl = document.getElementById('detailBody');
            const detail = builder(dashboardState) || {};
            titleEl.textContent = detail.title || 'Details';
            bodyEl.innerHTML = detail.content || detailEmptyState;
        }

        function openCardDetail(cardKey) {
            activeDetailCard = cardKey;
            renderCardDetail(cardKey);
            document.getElementById('cardDetailOverlay').classList.remove('hidden');
        }

        function closeCardDetail() {
            document.getElementById('cardDetailOverlay').classList.add('hidden');
            activeDetailCard = null;
        }

        function refreshActiveDetail(cardKey) {
            if (activeDetailCard === cardKey) {
                renderCardDetail(cardKey);
            }
        }

        function registerCardInteractions() {
            document.querySelectorAll('.card[data-card]').forEach(card => {
                card.addEventListener('click', () => openCardDetail(card.dataset.card));
                card.addEventListener('keypress', (event) => {
                    if (event.key === 'Enter' || event.key === ' ') {
                        event.preventDefault();
                        openCardDetail(card.dataset.card);
                    }
                });
            });

            document.getElementById('detailClose').addEventListener('click', closeCardDetail);
            document.getElementById('cardDetailOverlay').addEventListener('click', (event) => {
                if (event.target.id === 'cardDetailOverlay') {
                    closeCardDetail();
                }
            });
        }

        function updateTime() {
            const now = new Date();
            document.getElementById('lastUpdated').textContent = now.toLocaleString();
        }

        // Update time every second
        setInterval(updateTime, 1000);

        // API fetch functions
        async function fetchNetworkStats() {
            try {
                // Fetch BOTH intelligence data AND registered nodes data AND websocket active nodes
                const [intelResponse, nodesResponse, websocketResponse] = await Promise.all([
                    fetch('/api/v1/intelligence/health'),
                    fetch('/api/v1/nodes/list'),
                    fetch('/api/v1/websocket/active-nodes')
                ]);

                const intelData = await intelResponse.json();
                const nodesData = await nodesResponse.json();
                const websocketData = await websocketResponse.json();

                // Pass the correct data to each update function
                updateNetworkOverview(nodesData, websocketData);  // Node counts from nodes API + websocket unique count
                updateNetworkHealth(intelData);    // Health from intelligence API
                updateMiningStats({intelData, nodesData}); // Both for mining stats
            } catch (error) {
                console.error('Failed to fetch network stats:', error);
                // Set default values
                updateNetworkOverview({}, {});
                updateNetworkHealth({});
                updateMiningStats({});
            }
        }

        async function fetchBlockchainInfo() {
            try {
                // Use real blockchain data functions from MiningStatsAggregator
                const [blockchainResponse, mempoolResponse, syncResponse] = await Promise.all([
                    fetch('/api/v1/blockchain/info'),
                    fetch('/api/v1/blockchain/mempool'),
                    fetch('/api/v1/blockchain/sync-status')
                ]);

                const blockchainData = blockchainResponse.ok ? await blockchainResponse.json() : {};
                const mempoolData = mempoolResponse.ok ? await mempoolResponse.json() : {};
                const syncData = syncResponse.ok ? await syncResponse.json() : {};

                updateProtocolInfo(blockchainData);
                updateMempoolInfo(mempoolData);
                updateSyncStatus(syncData);
            } catch (error) {
                console.error('Failed to fetch blockchain info:', error);
                updateProtocolInfo({});
                updateMempoolInfo({});
                updateSyncStatus({});
            }
        }

        async function fetchRecentBlocks() {
            try {
                const response = await fetch('/api/v1/blockchain/recent-blocks?limit=10');
                const data = await response.json();
                updateRecentBlocks(data.blocks || []);
            } catch (error) {
                console.error('Failed to fetch recent blocks:', error);
                updateRecentBlocks([]);
            }
        }

        async function fetchMiningStatus() {
            try {
                // Get mining data from intelligence
                const response = await fetch('/api/v1/intelligence/health');
                const data = await response.json();
                updateMiningDetails(data);
            } catch (error) {
                console.error('Failed to fetch mining status:', error);
                updateMiningDetails({});
            }
        }

        async function fetchBootstrapRegistry() {
            try {
                const response = await fetch('/api/v1/bootstrap/registry');
                const data = await response.json();
                updateBootstrapNodes(data);
            } catch (error) {
                console.error('Failed to fetch bootstrap registry:', error);
                updateBootstrapNodes({});
            }
        }

        async function fetchServiceStatus() {
            try {
                const response = await fetch('/api/v1/services/status');
                const data = await response.json();
                updateServiceStatus(data);
            } catch (error) {
                console.error('Failed to fetch service status:', error);
                updateServiceStatus({});
            }
        }

        async function fetchRegisteredNodes() {
            try {
                const response = await fetch('/api/v1/nodes/list');
                const data = await response.json();
                updateRegisteredNodes(data);
            } catch (error) {
                console.error('Failed to fetch registered nodes:', error);
                updateRegisteredNodes({});
            }
        }

        async function fetchSentinelIntelligence() {
            try {
                // Fetch both attack detection and defense status data
                const [attacksResponse, defenseResponse, nodesResponse] = await Promise.all([
                    fetch('/api/v1/intelligence/attacks'),
                    fetch('/api/v1/intelligence/defense'),
                    fetch('/api/v1/nodes/list')
                ]);

                const attacksData = attacksResponse.ok ? await attacksResponse.json() : {};
                const defenseData = defenseResponse.ok ? await defenseResponse.json() : {};
                const nodesData = nodesResponse.ok ? await nodesResponse.json() : {};

                updateSentinelIntelligence({ attacksData, defenseData, nodesData });
            } catch (error) {
                console.error('Failed to fetch sentinel intelligence:', error);
                updateSentinelIntelligence({});
            }
        }

        // Update functions
        function updateNetworkOverview(data, websocketData) {
            // Use WebSocket connected nodes count if available (real-time deduplicated count)
            // Fall back to registered nodes count if WebSocket data not available
            let totalRegistered = data.total_registered_nodes || 0;
            const websocketActiveNodes = websocketData?.websocket_active_nodes || 0;
            
            // Prefer WebSocket count if it's available and smaller (deduped)
            // WebSocket tracks unique node_ids currently connected via any namespace
            if (websocketActiveNodes > 0 && websocketActiveNodes < totalRegistered) {
                totalRegistered = websocketActiveNodes;
            }
            
            const activeNodes = data.nodes?.filter(node => node.status === 'active').length || 0;

            const networkStatus = totalRegistered > 0 ? 'Active' : 'Initializing';
            const networkHashrate = '-- MH/s';
            const blockHeight = '--';
            const avgBlockTime = '--s';

            document.getElementById('totalNodes').textContent = totalRegistered;
            document.getElementById('activeNodes').textContent = activeNodes;
            document.getElementById('networkHashrate').textContent = networkHashrate; // Will be updated from mining data
            document.getElementById('blockHeight').textContent = blockHeight; // No blockchain data yet
            document.getElementById('avgBlockTime').textContent = avgBlockTime; // No blockchain data yet
            document.getElementById('networkStatus').textContent = networkStatus;

            dashboardState.networkOverview = {
                totalNodes: totalRegistered,
                activeNodes,
                networkStatus,
                networkHashrate,
                blockHeight,
                avgBlockTime,
                websocketActiveNodes, // For reference
                registeredNodes: data.total_registered_nodes // For reference
            };
            refreshActiveDetail('network-overview');
        }

        function updateNetworkHealth(data) {
            // Access nested intelligence_analysis data
            const intelligence = data.intelligence_analysis || {};
            const health = intelligence.network_health || {};
            const overallHealth = intelligence.overall_health || 0;

            document.getElementById('healthStatus').textContent = overallHealth > 80 ? 'Excellent' :
                overallHealth > 60 ? 'Good' : overallHealth > 40 ? 'Fair' : 'Poor';

            // Use real intelligence data
            const latency = health.avg_latency_ms || 'N/A';
            const latencyText = latency !== 'N/A' ? `${latency}ms` : '--ms';
            document.getElementById('avgLatency').textContent = latencyText;

            const packetLoss = '--%';
            const syncStatus = 'Active';
            const mempoolSize = '--';
            const pendingTransactions = '--';

            document.getElementById('packetLoss').textContent = packetLoss;
            document.getElementById('syncStatus').textContent = syncStatus;
            document.getElementById('mempoolSize').textContent = mempoolSize;
            document.getElementById('pendingTransactions').textContent = pendingTransactions;

            dashboardState.networkHealth = {
                overallHealth,
                healthStatus: document.getElementById('healthStatus').textContent,
                avgLatency: latencyText,
                packetLoss,
                syncStatus,
                mempoolSize,
                pendingTransactions
            };
            refreshActiveDetail('network-health');

            console.log(`‚úÖ Network health: ${overallHealth}% overall health`);
        }

        function updateMiningStats(data) {
            // Data now contains both intelData and nodesData
            const { intelData, nodesData } = data;
            const insights = intelData?.performance_insights || {};

            // Count active miners from registered nodes
            const allNodes = nodesData?.nodes || [];
            const minerNodes = allNodes.filter(node => node.node_type === 'miner');
            const activeMiners = minerNodes.filter(node => node.status === 'active').length;

            // Calculate total hashrate from active miners
            const totalHashrate = minerNodes
                .filter(node => node.status === 'active')
                .reduce((sum, node) => sum + (node.hashrate || 0), 0);

            const formattedHashrate = totalHashrate > 0 ? `${(totalHashrate / 1000000).toFixed(1)} MH/s` : '-- MH/s';

            document.getElementById('activeMiners').textContent = activeMiners;
            document.getElementById('totalHashrate').textContent = formattedHashrate;
            document.getElementById('blocksLastHour').textContent = '--'; // No blockchain data yet
            document.getElementById('avgBlocksPerHour').textContent = '--'; // No blockchain data yet
            document.getElementById('topMiners').textContent = minerNodes.length > 0 ?
                Math.min(minerNodes.length, 10) : '--'; // Show up to top 10

            dashboardState.miningStats = {
                activeMiners,
                totalHashrate: formattedHashrate,
                blocksLastHour: '--',
                avgBlocksPerHour: '--',
                topMinerCount: minerNodes.length > 0 ? Math.min(minerNodes.length, 10) : '--'
            };
            refreshActiveDetail('mining-stats');

            if (dashboardState.networkOverview) {
                dashboardState.networkOverview = {
                    ...dashboardState.networkOverview,
                    networkHashrate: formattedHashrate
                };
                refreshActiveDetail('network-overview');
            }

            console.log(`‚úÖ Mining stats: ${activeMiners} active miners, ${totalHashrate.toLocaleString()} H/s total hashrate`);
        }

        function updateProtocolInfo(data) {
            const version = data.protocol_version || '1.0.0';
            const networkId = data.network_id || 'pisecure-mainnet';
            const consensus = data.consensus || 'PoW + Intelligence';
            const blockTimeTarget = data.target_block_time || data.avg_block_time || 'Variable';
            const maxBlockSize = data.max_block_size || 'Dynamic';
            const supply = data.circulating_supply ?? '0';

            document.getElementById('protocolVersion').textContent = version;
            document.getElementById('networkId').textContent = networkId;
            document.getElementById('consensus').textContent = consensus;
            document.getElementById('blockTimeTarget').textContent = typeof blockTimeTarget === 'number'
                ? `${blockTimeTarget}s`
                : blockTimeTarget;
            document.getElementById('maxBlockSize').textContent = maxBlockSize;
            document.getElementById('circulatingSupply').textContent =
                typeof supply === 'number' ? supply.toLocaleString() : supply;

            dashboardState.protocolInfo = {
                version,
                networkId,
                consensus,
                blockTimeTarget: typeof blockTimeTarget === 'number' ? `${blockTimeTarget}s` : blockTimeTarget,
                maxBlockSize,
                circulatingSupply: typeof supply === 'number' ? supply.toLocaleString() : supply
            };
            refreshActiveDetail('protocol-info');
        }

        function updateMempoolInfo(data) {
            const size = data?.mempool_size ?? data?.size ?? null;
            const pending = data?.pending_transactions ?? data?.tx_count ?? null;

            document.getElementById('mempoolSize').textContent =
                size !== null ? `${size.toLocaleString()} tx` : '--';
            document.getElementById('pendingTransactions').textContent =
                pending !== null ? pending.toLocaleString() : '--';

            if (dashboardState.networkHealth) {
                dashboardState.networkHealth = {
                    ...dashboardState.networkHealth,
                    mempoolSize: size !== null ? `${size.toLocaleString()} tx` : '--',
                    pendingTransactions: pending !== null ? pending.toLocaleString() : '--'
                };
                refreshActiveDetail('network-health');
            }

            if (Array.isArray(data?.top_transactions) && data.top_transactions.length > 0) {
                console.log(`‚úÖ Mempool loaded with ${data.top_transactions.length} tracked transactions`);
            }
        }

        function updateSyncStatus(data) {
            const statusEl = document.getElementById('syncStatus');
            const statusValue = (data?.sync_status || data?.status || 'unknown').toLowerCase();
            let statusLabel = 'Unknown';
            let statusClass = 'status-initializing';

            if (statusValue === 'synced' || statusValue === 'healthy') {
                statusLabel = 'Synced';
                statusClass = 'status-healthy';
            } else if (statusValue === 'syncing' || statusValue === 'catching_up') {
                statusLabel = 'Syncing';
                statusClass = 'status-warning';
            } else if (statusValue === 'error' || statusValue === 'stalled') {
                statusLabel = 'Sync Error';
                statusClass = 'status-error';
            }

            statusEl.textContent = statusLabel;
            statusEl.className = `metric-value ${statusClass}`;

            const currentHeight = data?.current_height ?? data?.block_height;
            let blockHeightText = document.getElementById('blockHeight').textContent;
            if (typeof currentHeight === 'number') {
                document.getElementById('blockHeight').textContent = currentHeight.toLocaleString();
                blockHeightText = currentHeight.toLocaleString();
            }

            const avgBlockTime = data?.avg_block_time ?? data?.block_interval_seconds;
            let avgBlockTimeText = document.getElementById('avgBlockTime').textContent;
            if (typeof avgBlockTime === 'number') {
                document.getElementById('avgBlockTime').textContent = `${avgBlockTime.toFixed(1)}s`;
                avgBlockTimeText = `${avgBlockTime.toFixed(1)}s`;
            }

            const peers = data?.connected_peers ?? data?.peers;
            if (Array.isArray(peers)) {
                console.log(`‚úÖ Sync data: ${statusLabel}, ${peers.length} peers connected`);
            }

            if (dashboardState.networkOverview) {
                dashboardState.networkOverview = {
                    ...dashboardState.networkOverview,
                    networkStatus: statusLabel,
                    blockHeight: blockHeightText,
                    avgBlockTime: avgBlockTimeText
                };
                refreshActiveDetail('network-overview');
            }

            if (dashboardState.networkHealth) {
                dashboardState.networkHealth = {
                    ...dashboardState.networkHealth,
                    syncStatus: statusLabel
                };
                refreshActiveDetail('network-health');
            }
        }

        function updateMiningDetails(data) {
            // Update mining-related data from intelligence
            console.log('Intelligence data:', data);
        }

        function updateBootstrapNodes(data) {
            const content = document.getElementById('bootstrapNodesContent');

            // Show primary bootstrap info
            const primaryNode = data.primary_node;
            const secondaryNodes = data.secondary_nodes || [];
            const secondaryCount = secondaryNodes.length;
            const originNode = data.origin_node || null;
            if (primaryNode) {
                content.innerHTML = `
                    <div class="metric">
                        <span class="metric-label">${primaryNode.name || primaryNode.node_id}</span>
                        <span class="metric-value status-healthy">${primaryNode.status || 'active'}</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Role</span>
                        <span class="metric-value">${primaryNode.role || 'primary'}</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Operator</span>
                        <span class="metric-value">${primaryNode.operator || 'PiSecure Foundation'}</span>
                    </div>
                `;

                // Add secondary nodes count if available
                if (secondaryCount > 0) {
                    content.innerHTML += `
                        <div class="metric">
                            <span class="metric-label">Secondary Nodes</span>
                            <span class="metric-value">${secondaryCount}</span>
                        </div>
                    `;
                }
            } else {
                content.innerHTML = '<div class="metric"><span class="metric-value status-initializing">Loading bootstrap nodes...</span></div>';
            }

            if (originNode) {
                const localRole = (originNode.role || 'unknown').replace(/\b\w/g, char => char.toUpperCase());
                const badge = originNode.primary_domain_match ? 'Canonical Host' : originNode.role === 'primary' ? 'Acting Primary' : 'This Server';
                content.innerHTML += `
                    <div class="metric" style="margin-top:10px;">
                        <span class="metric-label">Current Server Role</span>
                        <span class="metric-value">${localRole} <small style="color:#00d4ff;">(${badge})</small></span>
                    </div>
                `;
            }

            dashboardState.bootstrapNodes = {
                primary: primaryNode,
                secondaryNodes,
                secondaryCount,
                primaryStatus: data.primary_status || {},
                origin: originNode
            };
            refreshActiveDetail('bootstrap-nodes');
        }

        function updateServiceStatus(data) {
            const content = document.getElementById('serviceStatusContent');

            if (data.services && typeof data.services === 'object') {
                let html = '';
                
                // Convert the services object to array entries
                Object.entries(data.services).forEach(([serviceName, serviceData]) => {
                    // Determine status class
                    let statusClass = 'status-healthy';
                    if (serviceData.status === 'active' || serviceData.health === 'healthy') {
                        statusClass = 'status-healthy';
                    } else if (serviceData.status === 'disabled' || serviceData.health === 'disabled') {
                        statusClass = 'status-initializing';
                    } else if (serviceData.status === 'not_implemented' || serviceData.health === 'awaiting_integration') {
                        statusClass = 'status-warning';
                    } else if (serviceData.status === 'error' || serviceData.health === 'error') {
                        statusClass = 'status-error';
                    }

                    // Format the service name nicely
                    const displayName = serviceName.split('_').map(word => 
                        word.charAt(0).toUpperCase() + word.slice(1)
                    ).join(' ');

                    html += `
                        <div class="metric">
                            <span class="metric-label">${displayName}</span>
                            <span class="metric-value ${statusClass}">${serviceData.health || serviceData.status}</span>
                        </div>
                    `;
                });

                content.innerHTML = html;
                console.log(`‚úÖ Service status: ${Object.keys(data.services).length} services, overall: ${data.overall_status}`);
            } else {
                content.innerHTML = '<div class="metric"><span class="metric-value status-initializing">Loading services...</span></div>';
            }

            dashboardState.serviceStatus = data;
            refreshActiveDetail('service-status');
        }

        function updateRecentBlocks(data) {
            const tbody = document.getElementById('blocksTableBody');

            // Since we don't have real blockchain data yet, show placeholder
            tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: #888;">Blockchain not yet initialized - waiting for mining to start</td></tr>';

            dashboardState.recentBlocks = Array.isArray(data) ? data : [];
            refreshActiveDetail('recent-blocks');
        }

        function updateRegisteredNodes(data) {
            // This function is called for logging purposes - the actual display updates
            // are handled by updateNetworkOverview which receives the same data
            const totalRegistered = data.total_registered_nodes || 0;
            const activeNodes = data.nodes?.filter(node => node.status === 'active').length || 0;

            console.log(`‚úÖ Registered nodes data: ${totalRegistered} total, ${activeNodes} active`);
        }

        function updateSentinelIntelligence(data) {
            const { attacksData, defenseData, nodesData } = data;

            // Get attacks intelligence
            const attacks = attacksData?.detected_attacks || [];
            const threatLevel = attacksData?.threat_level || 'unknown';
            
            // Get defense intelligence
            const defenseStatus = defenseData?.defense_status || {};
            const defenseEffectiveness = defenseStatus.effectiveness_score || 0;
            const blockedIPs = defenseStatus.blocked_ips?.length || 0;
            const threatZones = defenseStatus.threat_zones || [];
            
            // Check if the primary sentinel (Ghostwheel) is registered and active
            const allNodes = nodesData?.nodes || [];
            const sentinelNode = allNodes.find(node => 
                node.node_id === 'ghostwheel-sentinel-ai' || 
                node.node_type === 'sentinel_ai'
            );
            
            // Update threat level with color coding
            const threatLevelEl = document.getElementById('threatLevel');
            if (threatLevel === 'low') {
                threatLevelEl.textContent = 'üü¢ Low';
                threatLevelEl.className = 'metric-value status-healthy';
            } else if (threatLevel === 'medium') {
                threatLevelEl.textContent = 'üü° Medium';
                threatLevelEl.className = 'metric-value status-warning';
            } else if (threatLevel === 'high') {
                threatLevelEl.textContent = 'üî¥ High';
                threatLevelEl.className = 'metric-value status-error';
            } else if (threatLevel === 'critical') {
                threatLevelEl.textContent = 'üî¥ CRITICAL';
                threatLevelEl.className = 'metric-value status-error';
            } else {
                threatLevelEl.textContent = '‚ö™ Unknown';
                threatLevelEl.className = 'metric-value status-initializing';
            }
            
            // Update active attacks count
            const activeAttacksEl = document.getElementById('activeAttacks');
            activeAttacksEl.textContent = attacks.length;
            if (attacks.length === 0) {
                activeAttacksEl.className = 'metric-value status-healthy';
            } else if (attacks.length < 5) {
                activeAttacksEl.className = 'metric-value status-warning';
            } else {
                activeAttacksEl.className = 'metric-value status-error';
            }
            
            // Update defense effectiveness
            const defenseEffectivenessEl = document.getElementById('defenseEffectiveness');
            defenseEffectivenessEl.textContent = `${Math.round(defenseEffectiveness)}%`;
            if (defenseEffectiveness >= 80) {
                defenseEffectivenessEl.className = 'metric-value status-healthy';
            } else if (defenseEffectiveness >= 60) {
                defenseEffectivenessEl.className = 'metric-value status-warning';
            } else {
                defenseEffectivenessEl.className = 'metric-value status-error';
            }
            
            // Update blocked IPs
            document.getElementById('blockedIPs').textContent = blockedIPs;
            
            // Update threat zones
            document.getElementById('threatZones').textContent = 
                threatZones.length > 0 ? threatZones.join(', ') : 'None';
            
            // Update Sentinel status indicator
            const sentinelStatusEl = document.getElementById('sentinelStatus');
            if (sentinelNode && sentinelNode.status === 'active') {
                sentinelStatusEl.textContent = 'üü¢ Active';
                sentinelStatusEl.className = 'metric-value status-healthy';
            } else if (sentinelNode) {
                sentinelStatusEl.textContent = 'üü° Registered';
                sentinelStatusEl.className = 'metric-value status-warning';
            } else {
                sentinelStatusEl.textContent = '‚ö™ Not Connected';
                sentinelStatusEl.className = 'metric-value status-initializing';
            }
            
            dashboardState.sentinelIntelligence = {
                threatLevel: threatLevelEl.textContent,
                activeAttacks: attacks.length,
                defenseEffectiveness: `${Math.round(defenseEffectiveness)}%`,
                blockedIPs,
                threatZones,
                sentinelStatus: sentinelStatusEl.textContent
            };
            refreshActiveDetail('sentinel-intelligence');

            console.log(`‚úÖ Sentinel Intelligence: ${attacks.length} attacks, ${threatLevel} threat level, ${Math.round(defenseEffectiveness)}% effective`);
        }

        // Main update function
        async function updateAllData() {
            try {
                await Promise.all([
                    fetchNetworkStats(),
                    fetchBlockchainInfo(),
                    fetchMiningStatus(),
                    fetchBootstrapRegistry(),
                    fetchServiceStatus(),
                    fetchSentinelIntelligence()
                ]);

                lastUpdate = Date.now();
                updateTime();

                // Show success indicator
                console.log('‚úÖ Dashboard data updated successfully');

            } catch (error) {
                console.error('‚ùå Failed to update dashboard data:', error);
            }
        }

        // Fetch and display 314ST token valuation
        async function fetchTokenValuation() {
            try {
                // Get DEX market data
                let dexData = null;
                try {
                    const dexResponse = await fetch('/api/v1/dex/stats');
                    if (dexResponse.ok) {
                        dexData = await dexResponse.json();
                    }
                } catch (dexError) {
                    console.log('DEX not available yet:', dexError);
                }

                // Calculate market price (from DEX if available)
                const marketPrice = dexData?.dex_stats?.popular_pairs?.[0] ?
                    calculateMarketPriceFromDEX(dexData.dex_stats.popular_pairs[0]) : 0;

                // Fundamental value (fair launch economics)
                const fundamentalValue = 2.00; // $2.00 fair launch value

                // Calculate premium/discount
                const premium = marketPrice > 0 ? ((marketPrice - fundamentalValue) / fundamentalValue) * 100 : 0;

                // Update price overview
                document.getElementById('marketPrice').textContent = marketPrice > 0 ? `$${marketPrice.toFixed(2)}` : '--';
                document.getElementById('premiumDiscount').textContent = marketPrice > 0 ?
                    `${premium >= 0 ? '+' : ''}${premium.toFixed(1)}%` : '--';
                document.getElementById('premiumChange').textContent = premium > 20 ? 'üöÄ Above Fair Value' :
                    premium < -20 ? 'üìâ Below Fair Value' : '‚öñÔ∏è At Fair Value';

                // Update market status
                const marketStatusEl = document.getElementById('marketStatus');
                if (marketPrice === 0) {
                    marketStatusEl.textContent = '‚è≥ Pre-Market';
                    marketStatusEl.style.color = '#888';
                } else if (premium > 20) {
                    marketStatusEl.textContent = 'üìà Bullish';
                    marketStatusEl.style.color = '#00ff88';
                } else if (premium < -20) {
                    marketStatusEl.textContent = 'üìâ Bearish';
                    marketStatusEl.style.color = '#ff4444';
                } else {
                    marketStatusEl.textContent = '‚öñÔ∏è Neutral';
                    marketStatusEl.style.color = '#ffd43b';
                }

                // Update DEX market data
                document.getElementById('lastTrade').textContent = dexData ? '$1.85 (5 min ago)' : '--';
                document.getElementById('volume24h').textContent = dexData ?
                    `$${dexData.dex_stats.trading_volume_24h?.toLocaleString() || '0'}` : '--';
                document.getElementById('liquidity').textContent = dexData ?
                    `$${dexData.dex_stats.total_liquidity_314st?.toLocaleString() || '0'}` : '--';
                document.getElementById('activePools').textContent = dexData ?
                    dexData.dex_stats.total_pools || 0 : '--';

                // Update supply & demand
                const circulatingSupply = 0; // Will be updated when mining starts
                const marketCap = circulatingSupply * marketPrice;
                const fdv = 200000 * fundamentalValue; // 200K tokens at fair value

                document.getElementById('circulatingSupply').textContent = `${circulatingSupply.toLocaleString()} / 200,000 314ST`;
                document.getElementById('marketCap').textContent = marketCap > 0 ? `$${marketCap.toLocaleString()}` : '$0';
                document.getElementById('fdv').textContent = `$${fdv.toLocaleString()}`;
                document.getElementById('tokenVelocity').textContent = circulatingSupply > 0 ? '--' : '--';

                // Update market sentiment
                document.getElementById('priceMomentum').textContent = marketPrice === 0 ? '‚è≥ Pre-Market' :
                    premium > 10 ? 'üìà Strong Uptrend' : premium < -10 ? 'üìâ Downtrend' : '‚öñÔ∏è Sideways';
                document.getElementById('tradingActivity').textContent = dexData ? 'üü¢ Active Trading' : '‚è∏Ô∏è DEX Pending';
                document.getElementById('riskLevel').textContent = 'üî¥ High (Pre-Launch)';
                document.getElementById('confidenceScore').textContent = '75%';

                dashboardState.tokenValuation = {
                    marketPrice: marketPrice > 0 ? `$${marketPrice.toFixed(2)}` : '--',
                    fundamentalValue: `$${fundamentalValue.toFixed(2)}`,
                    premium: marketPrice > 0 ? `${premium >= 0 ? '+' : ''}${premium.toFixed(1)}%` : '--',
                    marketStatus: document.getElementById('marketStatus').textContent,
                    lastTrade: document.getElementById('lastTrade').textContent,
                    volume24h: document.getElementById('volume24h').textContent,
                    liquidity: document.getElementById('liquidity').textContent,
                    activePools: document.getElementById('activePools').textContent
                };
                refreshActiveDetail('token-valuation');

                console.log('‚úÖ Token valuation updated successfully');

            } catch (error) {
                console.error('Failed to fetch token valuation:', error);

                // Set default values for pre-market state
                document.getElementById('marketPrice').textContent = '--';
                document.getElementById('premiumDiscount').textContent = '--';
                document.getElementById('premiumChange').textContent = '--';
                document.getElementById('marketStatus').textContent = '‚è≥ Pre-Market';
                document.getElementById('lastTrade').textContent = '--';
                document.getElementById('volume24h').textContent = '--';
                document.getElementById('liquidity').textContent = '--';
                document.getElementById('activePools').textContent = '--';
                document.getElementById('tokenVelocity').textContent = '--';
                document.getElementById('priceMomentum').textContent = '‚è≥ Pre-Market';
                document.getElementById('tradingActivity').textContent = '‚è∏Ô∏è DEX Pending';

                dashboardState.tokenValuation = null;
                refreshActiveDetail('token-valuation');
            }
        }

        // Helper function to calculate market price from DEX data
        function calculateMarketPriceFromDEX(poolData) {
            // Simplified - in reality would get from order book or last trades
            const basePrice = 1.85; // Mock current DEX price
            const liquidityAdjustment = Math.log10(poolData.liquidity + 1) * 0.1;
            const volumeAdjustment = Math.log10(poolData.volume_24h + 1) * 0.05;

            return basePrice + liquidityAdjustment + volumeAdjustment;
        }

        // Fetch and display operator value estimation
        async function fetchOperatorValue() {
            try {
                // This would normally call a backend endpoint that calculates the value
                // For now, we'll calculate it client-side using the same logic
                const mockValueData = {
                    breakdown: {
                        intelligence_processing: { monthly_usd: 3600, description: 'ML-powered threat detection and optimization' },
                        dex_coordination_fees: { daily_usd: 50, monthly_usd: 1500, description: 'Percentage of DEX trading fees' },
                        network_monitoring: { hourly_usd: 25, monthly_usd: 18000, description: '24/7 network health monitoring' },
                        bootstrap_coordination: { hourly_usd: 30, monthly_usd: 21600, description: 'Peer discovery and federation coordination' },
                        uptime_bonus: { monthly_usd: 1200, percentage: 20, description: 'Bonus for 99.5% uptime' },
                        utility_value: { monthly_usd: 800, description: 'Attack prevention and improved user experience' },
                        operating_costs: { monthly_usd: 1080, description: 'Electricity, hosting, and infrastructure' },
                        operator_work_value: { monthly_usd: 720, description: 'Time and expertise investment' }
                    },
                    totals: {
                        gross_value_monthly_usd: 49000,
                        net_value_monthly_usd: 37200,
                        net_value_daily_usd: 1240,
                        net_value_hourly_usd: 52,
                        net_value_monthly_314st: 3720000,
                        net_value_daily_314st: 124000,
                        net_value_hourly_314st: 5200
                    }
                };

                // Update the value displays
                document.getElementById('monthlyValueUSD').textContent = `$${mockValueData.totals.net_value_monthly_usd.toLocaleString()}`;
                document.getElementById('monthlyValue314ST').textContent = `${mockValueData.totals.net_value_monthly_314st.toLocaleString()} 314ST`;
                document.getElementById('dailyValueUSD').textContent = `$${mockValueData.totals.net_value_daily_usd.toLocaleString()}`;
                document.getElementById('hourlyValueUSD').textContent = `$${mockValueData.totals.net_value_hourly_usd.toLocaleString()}`;

                // Update the breakdown
                const breakdownContainer = document.getElementById('valueBreakdown');
                let breakdownHTML = '';

                Object.entries(mockValueData.breakdown).forEach(([key, data]) => {
                    let valueText = '';
                    if (data.monthly_usd) {
                        valueText = `$${data.monthly_usd.toLocaleString()}/month`;
                    } else if (data.hourly_usd) {
                        valueText = `$${data.hourly_usd.toLocaleString()}/hour`;
                    } else if (data.daily_usd) {
                        valueText = `$${data.daily_usd.toLocaleString()}/day`;
                    } else if (data.percentage) {
                        valueText = `${data.percentage}%`;
                    }

                    breakdownHTML += `
                        <div class="breakdown-item">
                            <span class="breakdown-label">${data.description}</span>
                            <span class="breakdown-value">${valueText}</span>
                        </div>
                    `;
                });

                breakdownContainer.innerHTML = breakdownHTML;

                dashboardState.operatorValue = mockValueData;
                refreshActiveDetail('operator-value');

            } catch (error) {
                console.error('Failed to fetch operator value:', error);
                document.getElementById('valueBreakdown').innerHTML = `
                    <div class="breakdown-item">
                        <span class="breakdown-label">Error loading value analysis</span>
                        <span class="breakdown-value">N/A</span>
                    </div>
                `;
                dashboardState.operatorValue = null;
                refreshActiveDetail('operator-value');
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            registerCardInteractions();
            // Initial data load
            updateAllData();
            fetchOperatorValue();
            fetchTokenValuation();
            fetchRegisteredNodes();

            // Set up auto-refresh every 30 seconds
            setInterval(updateAllData, 30000);
            // Update operator value every 5 minutes
            setInterval(fetchOperatorValue, 300000);
            // Update token valuation every 2 minutes
            setInterval(fetchTokenValuation, 120000);
            // Update registered nodes every 2 minutes
            setInterval(fetchRegisteredNodes, 120000);
        });
    </script>
</body>
</html>